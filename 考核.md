 

# 1.1Java基础

##### java中常见的类以及类中常用的方法

![img](https://img-blog.csdnimg.cn/20190426180907525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE3Mzg2NA==,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20190427085253709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE3Mzg2NA==,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20190427101337705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE3Mzg2NA==,size_16,color_FFFFFF,t_70)

1.集合有哪三数据结构?初始长度?扩容机制? hashmap的底层原理

Collection

1. List

- Arraylist： Object数组
- Vector： Object数组
- LinkedList： 双向循环链表

1. Set

- HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素
- LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。
- TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。)

Map

- HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间
- LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。
- HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的
- TreeMap： 红黑树（自平衡的排序二叉树）

哪些集合类是线程安全的？

- vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。
- statck：堆栈类，先进后出。
- hashtable：就比hashmap多了个线程安全。
- enumeration：枚举，相当于迭代器。

说一下 HashMap 的实现原理？

HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。

HashMap的数据结构： 在Java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。

HashMap 基于 Hash 算法实现的

1. 当我们往Hashmap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标
2. 存储时，如果出现hash值相同的key，此时有两种情况。(1)如果key相同，则覆盖原始值；(2)如果key不同（出现冲突），则将当前的key-value放入链表中
3. 获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。
4. 理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。

需要注意Jdk 1.8中对HashMap的实现做了优化，当链表中的节点数据超过八个之后，该链表会转为红黑树来提高查询效率，从原来的O(n)到O(logn)

| 不同                     | JDK 1.7                                                      | JDK 1.8                                                      |
| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 存储结构                 | 数组 + 链表                                                  | 数组 + 链表 + 红黑树                                         |
| 初始化方式               | 单独函数：`inflateTable()`                                   | 直接集成到了扩容函数`resize()`中                             |
| hash值计算方式           | 扰动处理 = 9次扰动 = 4次位运算 + 5次异或运算                 | 扰动处理 = 2次扰动 = 1次位运算 + 1次异或运算                 |
| 存放数据的规则           | 无冲突时，存放数组；冲突时，存放链表                         | 无冲突时，存放数组；冲突 & 链表长度 < 8：存放单链表；冲突 & 链表长度 > 8：树化并存放红黑树 |
| 插入数据方式             | 头插法（先讲原位置的数据移到后1位，再插入数据到该位置）      | 尾插法（直接插入到链表尾部/红黑树）                          |
| 扩容后存储位置的计算方式 | 全部按照原来方法进行计算（即hashCode ->> 扰动函数 ->> (h&length-1)） | 按照扩容后的规律计算（即扩容后的位置=原位置 or 原位置 + 旧容量） |

HashMap的put方法的具体流程？

当我们put的时候，首先计算 `key`的`hash`值，这里调用了 `hash`方法，`hash`方法实际是让`key.hashCode()`与`key.hashCode()>>>16`进行异或操作，高16bit补0，一个数和0异或不变，所以 hash 函数大概的作用就是：**高16bit不变，低16bit和高16bit做了一个异或，目的是减少碰撞**。按照函数注释，因为bucket数组大小是2的幂，计算下标`index = (table.length - 1) & hash`，如果不做 hash 处理，相当于散列生效的只有几个低 bit 位，为了减少散列的碰撞，设计者综合考虑了速度、作用、质量之后，使用高16bit和低16bit异或来简单处理减少碰撞，而且JDK8中用了复杂度 O（logn）的树结构来提升碰撞下的性能。

HashMap的扩容操作是怎么实现的？

①.在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；

②.每次扩展的时候，都是扩展2倍；

③.扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。

在putVal()中，我们看到在这个函数里面使用到了2次resize()方法，resize()方法表示的在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值值(第一次为12),这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化的地方，在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发，但在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash & oldCap)是否为0，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上

putVal方法执行流程图

![img](https://img-blog.csdnimg.cn/20191214222552803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)

①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；

②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；

③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；

④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；

⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；

⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。

HashMap是使用了哪些方法来有效解决哈希冲突的：

**1. 使用链地址法（使用散列表）来链接拥有相同hash值的数据；**
​	**2. 使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；**
​	**3. 引入红黑树进一步降低遍历的时间复杂度，使得遍历更快；**

2.线程的创建? 开启?状态? sleep 和 wait 的区别?线程池?死锁?如何保证线程安全?

3. ==和equals的区别?

   覆盖equals时总要覆盖hashCode

     一个很常见的错误根源在于没有覆盖hashCode方法。在每个覆盖了equals方法的类中，也必须覆盖hashCode方法。如果不这样做的话，就会违反Object.hashCode的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这样的集合包括HashMap、HashSet和Hashtable。 

   - 在应用程序的执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。
   - 如果两个对象根据equals()方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果。
   - 如果两个对象根据equals()方法比较是不相等的，那么调用这两个对象中任意一个对象的hashCode方法，则不一定要产生相同的整数结果。但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表的性能。

equals代码怎么执行的？

```java
package equals;

public class Test {

        public static void main(String[] args) {
		String name1="Tom";
		String name2=new String("Tom");
		System.out.println(name1==name2);//false
		System.out.println(name1.equals(name2));
		}
	}
```

分析equals底层代码：

```java
 public boolean equals(Object anObject) {                    //name2为上转型对象
	        if (this == anObject) {            //因为name1与name2地址不同，所以走接下来的代码
	            return true;
	        }
	        if (anObject instanceof String) {         //因为anObject参数指向name2对象，name2为String类型对象，所以anObject instanceof String  是 true 实例 intanceof 类
	            String anotherString = (String)anObject;           //因为anObject参数指向name2对象，name2为String类型对象，所以可以下转型
	            int n = value.length;        //因为value是全局变量，实质是this.value.length，name1 调用 equals，this即为name1，name1就是全局变量，this.value.length就是name1的字符有多少个
	            if (n == anotherString.value.length) {                      //anotherString就是指向name2，anotherString.value.length代表name2有多少个字符。两个字符串相同，则长度一定相同，所以n == anotherString.value.length非常重要
	                char v1[] = value;//由name1字符组成的数组
	                char v2[] = anotherString.value;//由name2字符组成的数组
	                int i = 0;
	                while (n-- != 0) {             //逐个字符比对
	                    if (v1[i] != v2[i])              //只要有一个比对失败则两个字符串一定不相同
	                        return false;
	                    i++;
	                }
	                return true;
	            }
	        }
	        return false;
	     }
```

3. 对反射的理解? 获取Class类的方式有哪些?如何用反射取私有属性Filed?

5.常用设计模式有哪些?在项目中哪里有用到?

单例中懒汉饿汉优缺点?

饿汉式

```java
public class Singleton{
    //类加载时就初始化
    private static final Singleton instance = new Singleton();
    
    private Singleton(){}
 
    public static Singleton getInstance(){
        return instance;
    }
}

```

懒汉式

```java
public class Singleton {
    
    private static Singleton instance = null;
 
     //外界不能造对象 把无参构造方法私有
    private Singleton (){}
 
    //通过公共的方式对外提供  通过public修饰
    public static Singleton getInstance() {
     if (instance == null) {
         //类本身要造一个  调用构造方法即可
         instance = new Singleton();
     }
     return instance;
    }
}
```

双重锁

```java
//饱汉模式的双重锁模式，提高效率
public class Singleton3 {
	private volatile static Singleton3 singleton = null;//volatile防止指令重排序，内存可见(缓存中的变化及时刷到主存，并且其他的内存失效，必须从主存获取)
	
	private Singleton3(){
		//构造器必须私有  不然直接new就可以创建
	}
	
	public static Singleton3 getInstance(){
    //第一次判断，假设会有好多线程，如果Singleton3没有被实例化，那么就会到下一步获取锁，只有一个能获取到，
    //如果已经实例化，那么直接返回了，减少除了初始化时之外的所有锁获取等待过程
		if(singleton == null){
       //第二次判断是因为假设有两个线程A、B,两个同时通过了第一个if，然后A获取了锁，进入然后判断Singleton3是null，他就实例化了Singleton3，然后他出了锁，
       //这时候线程B经过等待A释放的锁，B获取锁了，如果没有第二个判断，那么他还是会去new Singleton3()，再创建一个实例，所以为了防止这种情况，需要第二次判断
			synchronized(Singleton3.class){
				if(singleton == null){
           //下面这句代码其实分为三步：
           //1.开辟内存分配给这个对象
           //2.初始化对象
           //3.将内存地址赋给虚拟机栈内存中的Singleton3变量
           //注意上面这三步，第2步和第3步的顺序是随机的，这是计算机指令重排序的问题
           //假设有两个线程，其中一个线程执行下面这行代码，如果第三步先执行了，就会把没有初始化的内存赋值给Singleton3
           //然后恰好这时候有另一个线程执行了第一个判断if(Singleton3 == null)，然后就会发现Singleton3指向了一个内存地址
           //这另一个线程就直接返回了这个没有初始化的内存，所以要防止第2步和第3步重排序
					singleton = new Singleton3();
				}
			}
		}
		return singleton;
	}
}

```



6.jdk1. 8的新特性有哪些?

- **Lambda表达式**：Lambda允许把函数作为一个方法的参数（函数作为参数传递到方法中）。
- **方法引用**：方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。
- **默认方法**：默认方法就是一个在接口里面有了一个实现的方法。
- **新工具**：新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。
- **Stream API**：新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。
- **Date Time API**：加强对日期与时间的处理。
- **Optional类**：Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。
- **Nashorn，JavaScript引擎**：JDK1.8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。
- **HashMap:**原来的HashMap集合底层是数组加链表，1.8以后引入了红黑树，当碰撞的元素个数大于8时 & 总容量大于64，会有红黑树的引入 ；1.8之后链表新进元素加到末尾
- **ConcurrentHashMap:**JDK1.8的实现已经摒弃了Segment的概念，而是直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用Synchronized和CAS来操作

7.session的实现原理? 

当客户端访问服务器时，服务器根据需求设置session，将会话信息保存在服务器上，同时将标示session的session_id传递给客户端浏览器，浏览器将这个session_id保存在内存中(还有其他的存储方式，例如写在url中)，我们称之为无过期时间的cookie。浏览器关闭后，这个cookie就清掉了，它不会存在用户的cookie临时文件。以后浏览器每次请求都会额外加上这个参数值，再服务器根据这个session_id，就能取得客户端的数据状态。

session 的生命周期?

session创建：

Sessinon在用户第一次访问服务器时创建，需要注意只有访问JSP、Servlet等程序时才会创建Session，只访问HTML、IMAGE等静态资源并不会创建Session，可调用request.getSession(true)强制生成Session。

session销毁：

1）Session超时：超时指的是连续一定时间服务器没有收到该Session所对应客户端的请求，并且这个时间超过了服务器设置的Session超时的最大时间。

2）程序调用HttpSession.invalidate()

3）服务器关闭或服务停止（session不会因为浏览器关闭而消失）

session如何存储数据?



8. 类加载机制?代码块的执行顺序?

9. cookie 和session 的区别?

10.java中字符串的方法有哪些? string stringbuild stringbuffer 的区别?

11. jvm调优和垃圾回收机制?

12. [java 中锁的种类和基本原理?](https://blog.csdn.net/qq_34827674/article/details/108608566?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control)

13. collection和collections的区别?

14. java如何跳出循环?

15.排序有哪些?原理是什么?

16. 什么是堆栈?什么是内存溢出?有垃圾回收机制为什么还会出现内存溢出的情况?

17. 内存模型的理解?

18. 泛型的理解?

19. java的基本类型有哪些，int 占几个字节? byte占几个字节?

20.常见的异常有哪些? 异常处理的方式有哪些?

21.枚举的了解?

22. final、 finally、 finalize 关键字的区别? volatile 关键字的了解?

23.在一个list中存放的String类型的字符串，如何实现把其中所有带“王”的字符串从list中去除?

24.array与list之间的转换

array->list:Arrays.asList(T...a)

list->array:list.toArray()

25. 如何序列化和反序列化? 序列化的目的?

# 1.2数据库

索引提高效率的原因

索引就是通过事先排好序，从而在查找时可以应用二分查找等高效率的算法。

索引底层实现

在 MySQL 中,索引属于存储引擎级别的概念,不同存储引擎对索引的实现方式是不同的,

**MyISAM 索引实现** (**非聚簇索引**)

**MyISAM 引擎使用 B+Tree 作为索引结构,叶节点的 data 域存放的是数据记录的地址**。

**InnoDB 索引实现** (**聚簇索引**)

InnoDB 也使用 B+Tree 作为索引结构,但具体实现方式却与 MyISAM 截然不同。

1.**第一个重大区别是 InnoDB 的数据文件本身就是索引文件。MyISAM 索引文件和数据文件是分离的,索引文件仅保存数据记录的地址**。

2.InnoDB 的**辅助索引 data 域存储相应记录主键的值而不是地址**。换句话说,InnoDB 的所有辅助索引都引用主键作为 data 域。

而在InnoDB 中,表数据文件本身就是按 B+Tree 组织的一个索引结构,这棵树的叶点data 域保存了完整的数据记录。这个索引的 key 是数据表的主键,因此 **InnoDB 表数据文件本身就是主索引。**

索引何时失效

  （1）组合索引未使用最左前缀，例如组合索引（A，B），where B=b不会使用索引；

​    （2）like未使用最左前缀，where A like '%China'；

​    （3）搜索一个索引而在另一个索引上做order by，where A=a order by B，只使用A上的索引，因为查询只使用一个索引 ；

​    （4）or会使索引失效。如果查询字段相同，也可以使用索引。例如where A=a1 or A=a2（生效），where A=a or B=b（失效）

​    （5）如果列类型是字符串，要使用引号。例如where A='China'，否则索引失效（会进行类型转换）；

​    （6）在索引列上的操作，函数（upper()等）、or、！=(<>)、not in等；

1.sql优化有哪些?如何创建索引?创建索引的原则是什么?索引的优缺点?

2. sql 如何去重?

3.内连接和外连接的区别?

4.Java中何使用Redis? Redis 支持的数据类型及各数据类型的使用场景? redis 如何解决数据过期?

5.数据库表的设计注意事项有哪些?三大范式的了解?

6.存储过程的 了解和使用?

数据库如何实现分页?

**一、mysql的分页算法**

mysql的分页算法最简单，就是使用limit关键字即可。

Mysql的分页sql使用在sql语句末端 + limit (起始位置),查询的数量，

如：select * from table where ... limit 起始位置,查询的数量(pageSize);

比如我们查询前10条的数据，如下面所示：

```
select * from tb_user limit 0,10
```

**二、sql servlet的分页算法**

sql server的分页算法也比较简单，示例如下：

**1、分页方案一**：(利用Not In和SELECT TOP分页)

如： select top 页大小[pagesize] * from  table where ( id not in(select top 页大小*当前页数 id from table order by  id)) order by id。

**2、 分页方案二**：(利用ID大于多少和SELECT TOP分页）

​     select top 页大小[pagesize] * from table where (id >(select max(id) from (select top 页大小*当前页数 id  from table order by id) as t)) order by id。 

**三、oracle的分页算法**

oracle分页算法最为复杂，实现方法也很多

**1、按ROWNUM来分【三层】**

```sql
select * from(select t.*,rownum rn from(select * from 【table】 order by 【id】 desc) t where  rownum<=10) where rn>0 
```

10是终止位，0起始位，rownum是oracle系统顺序分配为从查询返回的行的编号，返回的第一行分配的是1，第二行是2。

**2、按分析函数来分【两层】**

```sql
select * from (select t.*,row_number() over(order by cid desc) rk from 【table】t) where rk<10000 and rk>9980;
```

**3、根据ROWID来分【四层】**

```sql
select * from 【table】where rowid in(select rid from (select rownum rn,rid from(select rowid rid,cid from 【table】order by cid desc) where rownum<10000) where rn>9980) order by cid desc;
```

rowid是一个伪列，是用来确保表中行的唯一性，它并不能指示出行的物理位置，但可以用来定位行。 利用rowid是访问表中一行的最快方式。 

比如使用oracle实现对tb_user的分页查询

```sql
select * from(select t.*,rownum rn from(select * from tb_user ) t where  rownum<=10) where rn>0
```

百万级量的数据分页查询如何优化?

8.数据库的 乐观锁和悲观锁的理解和使用?

9.数据库中字符串 和日期的相互转换?

10. union 和unionAll区别?

11. mysql的存储引擎有哪些?

    MyISAM与InnoDB

    应用层的区别：

    1，MyISAM不支持外键，InnoDB支持，这是非关系型和关系型数据库的最大区别

    2，MyISAM不支持事务，InnoDB支持

    3，MyISAM不支持行锁，InnoDB支持，InnoDB也会退化为表锁

    4，MyISAM支持全文索引，InnoDB不支持（5.7版本后支持）

    5，MyISAM可以没有主键，InnoDB必须有（不设会内置）

    设计层的区别：

    1，先讲概念，什么是聚簇索引和非聚簇索引

    1.1，聚簇索引：主键索引的叶子节点存储主键值；

    1.2，非聚簇索引：主键索引的叶子节点不存储主键值，仅存主键值的地址；

    仅考虑算法层面的话，从聚簇索引中获取数据通常比在非聚簇索引中查找要快。

    2，MyISAM和InnoDB索引都采用B+树结构（这里不讨论hash），区别在于

    2.1，MyISAM主键索引是非聚簇索引；

    2.2，InnoDB主键索引是聚簇索引；

    2.3，InnoDB普通索引（二级索引）是非聚簇索引；

    3，数据存储方式的不同，如下图

    3.1，MyISAM索引文件和数据文件是分离的（.myi索引文件和.myd数据文件）

    3.2，InnoDB的数据文件按主键聚集（.idb数据文件）

    ![img](https://img-blog.csdnimg.cn/20200223221256388.png)

     

    4，为什么MyISAM查询更快？

    4.1，InnoDB要缓存数据块，MyISAM只缓存索引，加载索引可能更快

    4.2，InnoDB寻址先到块再到行，MyISAM直接寻址到文件offset

    4.3，InnoDB要维护MVCC一致

    总结：读多写少且不需要关联查询、事务，可以考虑用MyISAM。不然还是建议用InnoDB。



    12.事务的隔离级别有哪些?mysql和oracle默认的隔离级别是什么?
    
    13.sql 如何行转列和列转行?
    
    14.如何查看sql的执行计划?
    
    15.oracle 中的分析函数有哪些?
    
    16.数据库中除了聚合函数之外还有哪些常用的函数? oracle 数据库merge ()函数的作用和使用?
    
    17.sql中drop、truncate、 delete的区别?
    
    18.mysql 如何忽略表名的大小写?
    
    19.having 和where的区别?
    
    20.游标的作用和使用?
    
    21.如何使用数据库中的定时器、触发器、定时任务?
    
    22.oracle中如何实现递归查询?
    
    23.高并发下如何保证修改数据安全?
    
    24.oracle 中如何实现主键自增?
    
    25.delete 误删数据没有备份怎么恢复?
    
    26.oracle 死锁如何处理?

# 1.3框架

1.spring的特性是什么? ioc 和aop的原理是什么? aop 的注解有哪些?

特性：

​	IOC：

控制反转即IoC (Inversion of Control)，它把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。

Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。

​	 IoC 的实现原理就是工厂模式加反射机制。

​	AOP：

AOP(Aspect-Oriented Programming)，一般称为面向切面编程，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等。

![1609752032353](C:\Users\ASUS\Desktop\文件\考核.assets\1609752032353.png)

​	注解：

1.@Before 前置增强（目标方法执行之前，执行注解标注的内容）

2.@AfterReturning 后置增强（目标方法正常执行完毕后，执行）

3.@Around 环绕增强（目标方法执行前后，分别执行一些代码）

4.@AfterThrowing 抛出增强（目标方法发生异常，执行）

5.@After Final增强（不管是抛出异常还是正常退出，该增强都会得到执行。一般用于释放资源，相当于try{}finally{}）。

2. springboot 自动装配原理是什么? springboot 配置文件中常用配置有哪些? Springboot项目如何打包、部署、运行?

   自动装配原理：

   注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动配置的核心，

   @EnableAutoConfiguration 给容器导入META-INF/spring.factories 里定义的自动配置类。

   筛选有效的自动配置类。

   每一个自动配置类结合对应的 xxxProperties.java 读取配置文件进行自动配置功能

   常用配置：

   数据源，Mybatis，日志，Redis，

   [打包部署运行](https://blog.csdn.net/sinat_37239798/article/details/84062747?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160697503719725271654396%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=160697503719725271654396&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-1-84062747.pc_search_result_cache&utm_term=Springboot%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E6%89%93%E5%8C%85%E3%80%81%E9%83%A8%E7%BD%B2%E3%80%81%E8%BF%90%E8%A1%8C&spm=1018.2118.3001.4449)

3. [spring是如何控制事务的?](https://blog.csdn.net/weixin_40197494/article/details/83386417?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160697527419195271633069%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=160697527419195271633069&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-1-83386417.pc_search_result_cache&utm_term=spring%E6%98%AF%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E4%BA%8B%E5%8A%A1%E7%9A%84&spm=1018.2118.3001.4449)

   

   一、编程式事务控制；

   所谓编程式事务控制即通过编写代码的方式实现事务的控制。

   <!--配置事务管理器-->
   <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
   ​    <property name="dataSource" ref="dataSource"></property>
   ​     
   </bean>
   <!--事务管理器模板 方便使用事务-->
   <bean id="transactionTemplate" class="org.springframework.transaction.support.TransactionTemplate">
   ​    <property name="transactionManager" ref="transactionManager"></property>
   </bean>

   二、声明式事务控制。

   一、基于TransactionProxyFactoryBean代理的声明式事务控制；

   二、使用AOP的声明式事务控制；

   三、基于@Transactional注解的声明式事务控制。

4. springmvc常用注解及作用?

   @Controller控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。

   @RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。

   @RequestBody：注解实现接收http请求的json数据，将json转换为java对象。

   @ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。

5. springmvc的工作流程是什么?

   1）用户发送请求至前端控制器DispatcherServlet；
   （2） DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handle；
   （3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；
   （4）DispatcherServlet 调用 HandlerAdapter处理器适配器；
   （5）HandlerAdapter 经过适配调用 具体处理器(Handler，也叫后端控制器)；
   （6）Handler执行完成返回ModelAndView；
   （7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；
   （8）DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；
   （9）ViewResolver解析后返回具体View；
   （10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）
   （11）DispatcherServlet响应用户。

6.mybatis 的工作原理是什么? 

1）读取 MyBatis 配置文件：mybatis-config.xml 为 MyBatis 的全局配置文件，配置了 MyBatis 的运行环境等信息，例如数据库连接信息。

2）加载映射文件。映射文件即 SQL 映射文件，该文件中配置了操作数据库的 SQL 语句，需要在 MyBatis 配置文件 mybatis-config.xml 中加载。mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。

3）构造会话工厂：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory。

4）创建会话对象：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法。

5）Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。

6）MappedStatement 对象：在 Executor 接口的执行方法中有一个 MappedStatement 类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信息。

7）输入参数映射：输入参数类型可以是 Map、List 等集合类型，也可以是基本数据类型和 POJO 类型。输入参数映射过程类似于 JDBC 对 preparedStatement 对象设置参数的过程。

8）输出结果映射：输出结果类型可以是 Map、 List 等集合类型，也可以是基本数据类型和 POJO 类型。输出结果映射过程类似于 JDBC 对结果集的解析过程。

7.mybatis 的缓存的理解?

1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。

2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置`<cache/>` ；

3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。

8. mybatis中#{和${}的区别?
   - \#{}是占位符，预编译处理；${}是拼接符，字符串替换，没有预编译处理。
   - Mybatis在处理#{}时，#{}传入参数是以字符串传入，会将SQL中的#{}替换为?号，调用PreparedStatement的set方法来赋值。
   - Mybatis在处理时 ， 是 原 值 传 入 ， 就 是 把 {}时，是原值传入，就是把时，是原值传入，就是把{}替换成变量的值，相当于JDBC中的Statement编译
   - 变量替换后，#{} 对应的变量自动加上单引号 ‘’；变量替换后，${} 对应的变量不会加上单引号 ‘’
   - \#{} 可以有效的防止SQL注入，提高系统安全性；${} 不能防止SQL 注入
   - \#{} 的变量替换是在DBMS 中；${} 的变量替换是在 DBMS 外

9.[springboot的异常处理?](https://blog.csdn.net/qq_24598601/article/details/89243914?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160697624119195283098550%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=160697624119195283098550&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-1-89243914.pc_search_result_cache&utm_term=springboot%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86&spm=1018.2118.3001.4449)



10. [spring 中如何配置拦截器、过滤器?](https://blog.csdn.net/weixin_30664615/article/details/97076819?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control)



    **拦截器的实现**
    1.编写拦截器类实现HandlerInterceptor接口
    三个必须实现的方法
    preHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2) 
    （第一步：在请求被处理之前进行调用 是否需要将当前的请求拦截下来，如果返回false，请求将会终止，返回true，请求将会继续Object arg2表示拦截的控制器的目标方法实例）
    
    当进入拦截器链中的某个拦截器，并执行preHandle方法后
    
    postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2,ModelAndView arg3) 
    （第二步：在请求被处理之后进行调用ModelAndView arg3是指将被呈现在网页上的对象，可以通过修改这个对象实现不同角色跳向不同的网页或不同的消息提示）
    
    afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2，Exception arg3) 
    （第三步：在请求结束之后调用 一般用于关闭流、资源连接等 比较少用）
    
    过滤器实现：
    
    - 在HttpServletRequest到达Servlet之前，拦截客户的HttpServletRequest。
    
    - 根据需要检查HttpServletRequest，也可以修改HttpServletRequest头和数据。
    
    - 在HttpServletResponse到达客户端之前，拦截HttpServletResponse。
    
    - 根据需要检查HttpServletResponse，也可以修改HttpServletResponse头和数据。
    
    - 创建一个Filter只需两个步骤
    
      1. 创建Filter处理类
      2. web.xml文件中配置Filter
    
         创建Filter必须实现javax.servlet.Filter接口，在该接口中定义了如下三个方法。
    
      - void init(FilterConfig config):用于完成Filter的初始化。
      - void destory():用于Filter销毁前，完成某些资源的回收。
      - void doFilter(ServletRequest request,ServletResponse response,FilterChain chain):实现过滤功能，该方法就是对每个请求及响应增加的额外处理。该方法可以实现对用户请求进行预处理(ServletRequest request)，也可实现对服务器响应进行后处理(ServletResponse response)—它们的分界线为是否调用了chain.doFilter(),执行该方法之前，即对用户请求进行预处理；执行该方法之后，即对服务器响应进行后处理。

11. [spring 管理的bean是否会存在并发?](https://blog.csdn.net/jianjun200607/article/details/38758921?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160697720119721940228242%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=160697720119721940228242&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-8-38758921.pc_search_result_cache&utm_term=spring%20%E7%AE%A1%E7%90%86%E7%9A%84bean%E6%98%AF%E5%90%A6%E4%BC%9A%E5%AD%98%E5%9C%A8%E5%B9%B6%E5%8F%91&spm=1018.2118.3001.4449)

12. springsession 的原理是什么?

spring-session的原理是通过实现Filter创建过滤器SessionRepositoryFilter，在收到请求时采用装饰器模式重新分装HttpServletRequest和HttpServletResponse传递给FilterChain，之后对session的操作都交由SessionRepositoryRequestWrapper和SessionRepositoryResponseWrapper进行执行，以此来代替容器的session操作。

![1607308934252](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1607308934252.png)

13.spring的类加载器是什么?

ClassLoader类的介绍可以总结出这个类的作用就是根据一个指定的类的全限定名,找到对应的Class字节码文件,然后加载它转化成一个java.lang.Class类的一个实例.

- BootStrap ClassLoader：称为启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库，JAVA_HOME/JRE/lib/，如：rt.jar、resources.jar、charsets.jar等
- Extension ClassLoader：称为扩展类加载器，负责加载Java的扩展类库，默认加载JAVA_HOME/JRE/lib/ext/目下的所有jar
- App ClassLoader：称为系统类加载器，负责加载应用程序classpath目录下的所有jar和class文件

14.springCloud的组件有哪些?作用分别是什么?

**Eureka:服务启动时,Eureka会将服务注册到EurekaService,并且EurakeClient还可以返回过来从EurekaService拉去注册表,从而知道服务在哪里**

**Ribbon:服务间发起请求的时候,基于Ribbon服务做到负载均衡,从一个服务的对台机器中选择一台**

**Feign:基于fegin的动态代理机制,根据注解和选择机器,拼接Url地址,发起请求**

**Hystrix:发起的请求是通过Hystrix的线程池来走,不同的服走不同的线程池,实现了不同的服务调度隔离,避免服务雪崩的问题**

**Zuul:如果前端后端移动端调用后台系统,统一走zull网关进入,有zull网关转发请求给对应的服务**

15.dubbo和springc loud的区别和优缺点?

1、dubbo由于是二进制的传输，占用带宽会更少

2、springCloud是http协议传输，带宽会比较多，同时使用http协议一般会使用JSON报文，消耗会更大

3、dubbo的开发难度较大，原因是dubbo的jar包依赖问题很多大型工程无法解决

4、springcloud的接口协议约定比较自由且松散，需要有强有力的行政措施来限制接口无序升级

5、dubbo的注册中心可以选择zk,redis等，springcloud的注册中心用eureka或者Consul

16.Gateway 的动态路由如何实现?

1.默认情况下Gateway会根据注册中心注册的服务列表，以注册中心上微服务名为路径创建动态路由进行转发，从而实现动态路由的功能。

2.基于Nacos实现Spring Cloud Gateway实现动态路由的方法

3.[继承RouteDefinitionRepository实现](https://blog.csdn.net/u012661488/article/details/106891386/?ops_request_misc=&request_id=&biz_id=102&utm_term=Gateway%2520%25E7%259A%2584%25E5%258A%25A8%25E6%2580%2581%25E8%25B7%25AF%25E7%2594%25B1%25E5%25A6%2582%25E4%25BD%2595%25E5%25AE%259E%25E7%258E%25B0?&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-8-106891386.nonecase)

17.[鉴权框架的了解和使用?](https://blog.csdn.net/lovexiaotaozi/article/details/104156072/?utm_medium=distribute.pc_relevant.none-task-blog-utm_term-2&spm=1001.2101.3001.4242)



    18. mybatis同时操作同条数据该怎么解决并发问题?
    
           银行两操作员同时操作同一账户就是典型的例子。比如A、B操作员同时读取一余额为1000元的账户，A操作员为该账户增加100元，B操作员同时为该账户减去 50元，A先提交，B后提交。 最后实际账户余额为1000-50=950元，但本该为 1000+100-50=1050。这就是典型的并发问题
    
           一个简单的解决办法：更新的时候给版本号字段加上 1，然后 UPDATE 会返回一个更新结果的行数，通过这个行数去判断。



        ​    update account set price = #price #,version=version+1
    
        ​                              where id=#id# and version=#vsersion#



              如果更新执行返回的数量是 0 表示产生并发修改了，需要重新获得最新的数据后再进行更新操作。


              Hibernate、JPA 等 ORM 框架或者实现，是使用版本号，再判断 UPDATE 后返回的数值，如果这个值小于 1 时则抛出乐观锁并发修改异常。
    
    19. mbatis中传递参数有哪些方式?
    
        - [方式一、顺序传递参数]
        - [方式二、注解@Param传递参数]
        - [方式三、使用Map集合传递参数]
        - [方式四、使用JavaBean实体类传递参数]

20.spring 中bean的生命周期?作用域有哪些?

生命周期：

Spring对bean进行实例化；

Spring将值和bean的引用注入到bean对应的属性中；

如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法；

如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；

如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；

如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法；

如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用initmethod声明了初始化方法，该方法也会被调用；

如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法；

此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；

如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。

现在你已经了解了如何创建和加载一个Spring容器。但是一个空的容器并没有太大的价值，在你把东西放进去之前，它里面什么都没有。为了从Spring的DI(依赖注入)中受益，我们必须将应用对象装配进Spring容器中。

作用域：

- **singleton :** bean在每个Spring ioc 容器中只有一个实例。
- **prototype**：一个bean的定义可以有多个实例。
- **request**：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。
- **session**：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。
- **global-session**：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。

21. 怎么实现mybatis 批量插入?

    ![1606981033926](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1606981033926.png)![1606981115923](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1606981115923.png)

22.[junit如何使用?](https://www.cnblogs.com/z0228-0322x/p/6163950.html)



23. spring的工厂模式如何使用?

    工厂模式：定义一个用于创建对象的接口，让子类决定具体实例化哪一个类。使类的实例化延迟到子类。

    解耦

    1、通过读取配置文件来获取创建的对象全限定类名
    2、通过反射来创建对象，尽量避免使用new关键字

24. springboot 是如何对线程进行封装的?





25.springboot中Starter种类有哪些?

spring-boot-starter-web 嵌入tomcat和web开发需要servlet与jsp支持
spring-boot-starter-data-jpa 数据库支持
spring-boot-starter-data-redis redis数据库支持
spring-boot-starter-data-solr solr支持
mybatis-spring-boot-starter 第三方的mybatis集成starter

[如何写一个springboot的Starter组件?](https://blog.csdn.net/qianlia/article/details/106521273?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160698242419726885856049%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=160698242419726885856049&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-1-106521273.pc_search_result_cache&utm_term=%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AAspringboot%E7%9A%84Starter%E7%BB%84%E4%BB%B6&spm=1018.2118.3001.4449)

- 引入 spring-boot-autoconfigure 依赖
- 创建配置实体类
- 创建自动配置类，设置实例化条件（@Conditionalxxx注解，可不设置），并注入容器
- 在 MATE-INF 文件夹下创建 spring.factories 文件夹，激活自动配置。
- 在 maven 仓库发布 starter

26.设计一个开放接口， 如何保证接口安全性?

1、客户端通过用户名密码登录服务器并获取Token

2、客户端生成时间戳timestamp，并将timestamp作为其中一个参数

3、客户端将所有的参数，包括Token和timestamp按照自己的算法进行排序加密得到签名sign

4、将token、timestamp和sign作为请求时必须携带的参数加在每个请求的URL后边（http://url/request?token=123&timestamp=123&sign=123123123）

5、服务端写一个过滤器对token、timestamp和sign进行验证，只有在**token有效、timestamp未超时、缓存服务器中不存在sign**三种情况同时满足，本次请求才有效

# 1.4实用技术

1.文件上传 和下载如何实现?

![1608165674033](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1608165674033.png)

![1608165692972](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1608165692972.png)

![1608165717215](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1608165717215.png)

[使用Netty](https://blog.csdn.net/b379685397/article/details/103705185?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160732518219725271082162%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=160732518219725271082162&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-103705185.nonecase&utm_term=%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%20%E5%92%8C%E4%B8%8B%E8%BD%BD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0#%E4%BA%8C%E3%80%81Netty%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD)

**[FastDFS](https://www.jianshu.com/p/3f24bb9bb742)**

一,借助三方工具类实现上传文件

![1608000405413](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1608000405413.png)

**上传步骤**： 
１、创建解析工厂DiskFileItemFactory对象 
２、使用DiskFileItemFactory 对象创建ServletFileUpload对象。 
３、调用ServletFileUpload.parseRequest方法解析request对象，得到一个保存了所有上传内容的List对象。 
４、对list进行迭代，每迭代一个FileItem对象，调用其isFormField方法判断是否为附件 
5、普通表单字段，则调用getFieldName、getString方法得到字段名和字段值 
6、文件，则调用getInputStream方法得到数据输入流，从而读取上传数据。

二[,用springmvc框架中的类– 不过需要在springmvc.xml中配置上传文件解析器](https://blog.csdn.net/qq_39494996/article/details/82085286?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160732531819215668899685%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D&request_id=160732531819215668899685&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-82085286.nonecase&utm_term=%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0)

**上传**

1、设置表单的enctype=“multipart/form-data”，methos必须为post

2、在servlet中加上@MultipartConfig注解（文件上传是后来加入的技术，所以需要申明一下）

3、在servlet中使用request.getPart(“参数名”)获取单个文件或request.getParts()获取上传的文件的集合。

4、通过part.getHeader(“content-disposition”);或者String fileName = p.getSubmittedFileName();来获取文件名和后缀。文件名为中文的时候需要加上request.setCharacterEncoding(“utf-8”);才会不乱码。

5、通过part.write(filePath+fileName);将文件写到本地指定目录中。

![1608000392466](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1608000392466.png)

​	**下载**
1）步骤：
①.设置contentType响应头：设置响应的类型是什么？通知浏览器是个下载的文件
response.setContentType("application/x-msdownload");
②.设置Content-Disposition响应头：通知浏览器不在有浏览器来自行处理（或打开）要下载的文件，而由用户手工完成。
response.setHeader("Content-Disposition", "attachment,filename=abc.txt");
③.具体的文件：可以代用response.getOutputStream的方式，以IO流 的方式发送给客户端。

**下载步骤**： 
1.设置文件ContentType类型 “multipart/form-data“ 
2.设置文件头 “Content-Disposition”, “attachment;fileName=文件名” 
3.通过response获取ServletOutputStream对象(out) 
4.通过输出流(out)向浏览器响应文件



2.第三方的工作流有哪些?如何使用的?

[Activiti](https://blog.csdn.net/babylovewei/article/details/85166182?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160860313116780273322585%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D&request_id=160860313116780273322585&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-85166182.nonecase&utm_term=Activiti)

https://blog.csdn.net/fxq8866/article/details/54882651

![1608025965089](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1608025965089.png)

[Git工作流](https://blog.csdn.net/prettyshuang/article/details/51279466?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160800123616780274064820%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D&request_id=160800123616780274064820&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-51279466.nonecase&utm_term=%E7%AC%AC%E4%B8%89%E6%96%B9%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%9C%89%E5%93%AA%E4%BA%9B)

Workflow.Net、NetBpm、OSWorkflow

3.[对 activemq、rabbitmq、kafuka 的了解和使用?](https://blog.csdn.net/yy339452689/article/details/103968481)

![1607582409135](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1607582409135.png)

订阅方式：

ActiveMQ：点对点(p2p)、广播（发布-订阅）；

RabbitMQ：work queue(工作队列)、Publish/Subscribe(发布订阅模式)、Routing(路由模式)、Topic(通配符模式)、Hreader()、RPC()；

Kafka：点对点(p2p)

使用：

ActiveMQ：

在项目中，我们使用的是SpringJMS操作activeMQ，已maven操作为例,首先先引用SpringJMS的依赖 及 activeMQ的依赖，然后在spring的配置中，
如果要配置消息的生产者的话，需要配置springjms的连接工厂，通过连接工厂配置 jmsTemplate实例，我们可以使用jmsTemplate进行消息的相关操作，另外我们也需要配置消息的目的地，也是在spring的配置文件中配置配置队列 或者 主题。
消息的消费者和生产者配置差不多，不同的是需要配置一个消息的监听器，监听器里面实现onMessage方法，在这个方法里面处理消息

RabbitMQ：

在我们秒杀抢购商品的时候，系统会提醒我们稍等排队中，而不是像几年前一样页面卡死或报错给用户。

像这种排队结算就用到了消息队列机制，放入通道里面一个一个结算处理，而不是某个时间断突然涌入大批量的查询新增把数据库给搞宕机，所以RabbitMQ本质上起到的作用就是削峰填谷，为业务保驾护航。

- 服务间异步通信
- 顺序消费
- 定时任务
- 请求削峰

Kafka：

- 日志收集：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、HBase、Solr等。
- 消息系统：解耦和生产者和消费者、缓存消息等。
- 用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。
- 运营指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。
- 流式处理：比如spark streaming和 Flink

消息发送失败如何处理?

1.自动重发



2.系统预警人工处理等

![1608004637855](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1608004637855.png)

如何防止消息的重复消费?

​	保证消息的唯一性，就算是多次传输，不要让消息的多次消费带来影响；保证消息等幂性；

​	比如：在写入消息队列的数据做唯一标示，消费消息时，根据唯一标识判断是否消费过；

​	1、对于需要保存到数据库的数据，我们可以设置某条数据的某个值，比如订单号之类的，设置一个唯一索引，这样的话即使重复消费也不会生效数据
​		2、乐观锁，也就是我们每次插入一条数据或者更新的时候判断某个版本号是不是与预期一样，如果不是，那么就不进行操作
​		3、使用redis进行存储，保留我们消费过的数据的每个特征，然后每次操作数据的时候先去redis进行判断，如果存在的话，那么这条数据就是重复消费的，然后我们可以丢弃或者做其他处理。

4.svn和git冲突如何解决?

SVN解决冲突有三种选择：

​	A、放弃自己的更新，使用svn revert（回滚），然后提交。在这种方式下不需要使用svn resolved（解决）

​	B、放弃自己的更新，使用别人的更新。使用最新获取的版本覆盖目标文件，执行resolved filename并提交(选择文件—右键—解决)。

​	C、手动解决：冲突发生时，通过和其他用户沟通之后，手动更新目标文件。然后执行resolved filename来解除冲突，最后提交。

Git

1）直接修改文件

第一步，选择文件鼠标右击选择 Git-commit --提交到本地仓库

第二部，在文件同级空白处鼠标右击选择 tortoisGit --> pull，文件发生改变。

直接修改文件中数据，最后保存文件

第三步，选择文件鼠标右击选择 Git Commit --> 提交 -- >push 发布。

2）通过edit conflicts修改

选中文件，右击菜单选项 tortoiseGit --> Edit conflict

 ![img](https://images2015.cnblogs.com/blog/1128526/201705/1128526-20170509003824113-1872132501.png)

修改编辑区：将Theirs- 或者 Local-中需要的数据添加到Meged中。

 ![img](https://images2015.cnblogs.com/blog/1128526/201705/1128526-20170509003839113-889285740.png)

保存时 标记冲突解决

 ![img](https://images2015.cnblogs.com/blog/1128526/201705/1128526-20170509003846519-1639704885.png)

5.如何测试自己的接口?

postman、jmeter、soupUI、java+httpclient、robotframework+httplibrary等

6.poi导入excel时如果数据溢出如何解决?

​	POI官方推荐解决内存溢出的方式使用CSV格式解析

7.linux 常用命令有哪些?

pwd                   # 查看你当前所在的目录
cd                    # 切换目录
ls                    # 查看显示目录的内容
du                    # 统计目录和文件空间的占用情况
mkdir                 # 创建新目录
rmdir                 # 删除空目录
touch                 # 创建文件
rm                    # 删除文件
ln                    # 创建硬链接
ln -s                 # 创建软链接
cp                    # 复制文件或目录
mv                    # 移动文件或目录
which                 # 查看linux命令所在的目录

8.[如何调用第三方的接口?](https://blog.csdn.net/helloworlddm/article/details/80521505?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160758431219721940296259%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=160758431219721940296259&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-80521505.nonecase&utm_term=%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E7%9A%84%E6%8E%A5%E5%8F%A3&spm=1018.2118.3001.4449)

ajax

from表单（form的action方法）

httpclient

feign

9.分布式、 集群、微服务的理解?

- 分布式：一个业务分拆多个子业务，部署在不同的服务器上
- 集群：同一个业务，部署在多个服务器上
- 微服务是一种架构风格，一个大型复杂软件应用由一个或多个微服务组成。系统中的各个微服务可被独立部署，各个微服务之间是松耦合的，通过接口来实现数据的交互。每个微服务仅关注于完成一件任务并很好地完成该任务。在所有情况下，每个任务代表着一个小的业务能力。

[分布式与微服务的区别](https://blog.csdn.net/adsadadaddadasda/article/details/81223231?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160802189219726891175603%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D&request_id=160802189219726891175603&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-81223231.nonecase&utm_term=%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8C%BA%E5%88%AB)

分布式属于微服务

分布式：分布压力(集群)

微服务：分布能力

10. 分布式事务的处理逻辑?怎么实现的?
11. 事务的特性?分布式如何保证数据一致性?

ACID

  数据的一致性协议有：

​        \1.  [两阶段提交协议  2PC](https://blog.csdn.net/daziyuanazhen/article/details/100637152?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160811044416780257475913%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fblog.%252522%25257D&request_id=160811044416780257475913&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-100637152.pc_v2_rank_blog_default&utm_term=%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%8D%8F%E8%AE%AE%20%202PC)

​        [\2.  三阶段提交协议  3PC](https://blog.csdn.net/aa1215018028/article/details/81158224?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160811061716780288279227%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D&request_id=160811061716780288279227&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~top_click~default-3-81158224.pc_v2_rank_blog_default&utm_term=3PC)

​        \3.  RWN协议

​        \4.  raft协议

​        \5.  Paxos协议

12.docker的常用命令有哪些?![1607585595516](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1607585595516.png)

![1607585506493](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1607585506493.png)

13. 模板引擎的了解和使用?

    模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。

    模板引擎有哪些：jsp、Velocity、FreeMarker、[Thymleaf](https://blog.csdn.net/liuduke1/article/details/108508006?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160758591316780308352708%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=160758591316780308352708&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-108508006.nonecase&utm_term=%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E7%9A%84%E4%BA%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8&spm=1018.2118.3001.4449#Thymeleaf_44)、Beetl、Enjoy。

    [freemarker](https://blog.csdn.net/qq_34253619/article/details/83824956?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control)：

    1,创建Configuration实例,该实例负责管理FreeMarker的模板加载路径,负责生成模板实例
    2,使用Configuration实例来生成Template实例,同进需要指定使用的模板文件
    3,填充数据模型,数据模型就是一个Map对象

    4,调用Template实例的process方法完成合并

14. [项目中定时任务怎么写的?](https://my.oschina.net/u/566591/blog/1579950)

    1.最简单的一种：在线程中执行 `Thread.sleep()`，休眠挂起线程，等待一段时间后再执行

    2.借助Timer和TimerTask实现定时任务

    3.借助调度线程池 `Executors.newScheduledThreadPool()` 实现定时任务

    4.借助第三方工具，如spring的定时任务； Quartz；

15.[如何实现邮箱和短信的发送?](https://blog.csdn.net/ycf921244819/article/details/103858177?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160758640719195271641818%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=160758640719195271641818&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-5-103858177.nonecase&utm_term=%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%82%AE%E7%AE%B1%E5%92%8C%E7%9F%AD%E4%BF%A1%E7%9A%84%E5%8F%91%E9%80%81&spm=1018.2118.3001.4449)

短信：阿里云SMS，百度云SMS，七牛云SMS等

邮件：

进入邮箱设置，将其开启POP3/SMTP服务，以允许我们通过第三方客户端发送邮件。并且获取授权码（不是登录密码） 
​	使用JavaMail发送邮件非常简单，也是三步曲： 
​	创建连接对象javax.mail.Session 
​	创建邮件对象 javax.mail.Message 
​	发送邮件 

16.两个异构项目之间的实时数据互通你会怎么做?

​		[Dubbo](https://blog.csdn.net/csdnnews/article/details/104549211?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160810999816780288715872%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=160810999816780288715872&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-19-104549211.nonecase&utm_term=%E4%B8%A4%E4%B8%AA%E5%BC%82%E6%9E%84%E9%A1%B9%E7%9B%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E5%AE%9E%E6%97%B6%E6%95%B0%E6%8D%AE%E4%BA%92%E9%80%9A%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%81%9A)-多协议，多注册中心

​		[Web Service](https://blog.csdn.net/liujiahan629629/article/details/23716357?biz_id=102&utm_term=%E4%B8%A4%E4%B8%AA%E5%BC%82%E6%9E%84%E9%A1%B9%E7%9B%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E5%AE%9E%E6%97%B6%E6%95%B0%E6%8D%AE%E4%BA%92%E9%80%9A%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%81%9A&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-23716357&spm=1018.2118.3001.4449)-基于CXF规范，采用JAX-WS方式开发接口，

17. nginx 的了解和使用?

Nginx是一个高性能的HTTP和反向代理web服务器，同时也提供IMAP/POP3/SMTP服务

主要功能：反向代理，通过配置文件可以实现集群和负载均衡，静态资源虚拟化

18.[maven如何解决jar包冲突?](https://blog.csdn.net/noaman_wgs/article/details/81137893?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160758699619724816657103%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=160758699619724816657103&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-81137893.nonecase&utm_term=maven%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3jar%E5%8C%85%E5%86%B2%E7%AA%81&spm=1018.2118.3001.4449)

1、 Maven默认处理策略

- 最短路径优先

- 最先声明优先

2、移除依赖：用于排除某项依赖的依赖jar包

（1）我们可以借助Maven Helper插件中的Dependency Analyzer分析冲突的jar包，然后在对应标红版本的jar包上面点击execlude，就可以将该jar包排除出去。
![这里写图片描述](https://img-blog.csdn.net/20180720195338208?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25vYW1hbl93Z3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
再刷新以后冲突就会消失。

（2）手动排除
或者手动在pom.xml中使用`<exclusion>`标签去排除冲突的jar包（上面利用插件Maven Helper中的execlude方法其实等同于该方法）：

mvn分析包冲突命令：

```
mvn dependency:tree
```

3 版本锁定原则：一般用在继承项目的父项目中

正常项目都是多模块的项目，如moduleA和moduleB共同依赖X这个依赖的话，那么可以将X抽取出来，同时设置其版本号，这样X依赖在升级的时候，不需要分别对moduleA和moduleB模块中的依赖X进行升级，避免太多地方（moduleC、moduleD…）引用X依赖的时候忘记升级造成jar包冲突，这也是实际项目开发中比较常见的方法。

19.[树形结构的表怎么设计的?](https://blog.csdn.net/qq_38011415/article/details/95462698?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160758707619724827620393%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=160758707619724827620393&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-95462698.nonecase&utm_term=%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E7%9A%84%E8%A1%A8%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%E7%9A%84&spm=1018.2118.3001.4449)

![1607587121853](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1607587121853.png)

可以将邻接表方式与闭包表方式相结合使用。实际上就是将父id冗余到主表中，在一些只需要查询直接关系的业务中就可以直接查询主表，而不需要关联2张表了。在需要跨级查询时祖先后代关系表就显得尤为重要。

- 只需要建立子父集关系中可以使用邻接表方式 ;
- 涉及向上查找，向下查找的需要建议使用闭包表方式 ;

20.如何实现菜单及增删改查的功能权限管理?

SpringSecurity 

Shiro

21.开发程序需要哪些文档?

  1、可行性分析报告 

说明该软件开发项目的实现在技术上、经济上和社会因素上的可行性，评述为了合理地达到开发目标可供选择的各种可能实施方案，说明并论证所选定实施方案的理由。 

2、项目开发计划 

为软件项目实施方案制订出具体计划，应该包括各部分工作的负责人员、开发的进度、开发经费的预算、所需的硬件及软件资源等。 

3、软件需求说明书（软件规格说明书） 

对所开发软件的功能、性能、用户界面及运行环境等作出详细的说明。它是在用户与开发人员双方对软件需求取得共同理解并达成协议的条件下编写的，也是实施开发工作的基础。该说明书应给出数据逻辑和数据采集的各项要求，为生成和维护系统数据文件做好准备。 

4、概要设计说明书 

该说明书是概要实际阶段的工作成果，它应说明功能分配、模块划分、程序的总体结构、输入输出以及接口设计、运行设计、数据结构设计和出错处理设计等，为详细设计提供基础。 

5、详细设计说明书 

着重描述每一模块是怎样实现的，包括实现算法、逻辑流程等。 

6、用户操作手册 

本手册详细描述软件的功能、性能和用户界面，使用户对如何使用该软件得到具体的了解,为操作人员提供该软件各种运行情况的有关知识，特别是操作方法的具体细节。 

7、测试计划 

为做好集成测试和验收测试，需为如何组织测试制订实施计划。计划应包括测试的内容、进度、条件、人员、测试用例的选取原则、测试结果允许的偏差范围等。 

8、测试分析报告 

测试工作完成以后，应提交测试计划执行情况的说明，对测试结果加以分析，并提出测试的结论意见。 

9、开发进度月报 

该月报系软件人员按月向管理部门提交的项目进展情况报告，报告应包括进度计划与实际执行情况的比较、阶段成果、遇到的问题和解决的办法以及下个月的打算等。 

10、项目开发总结报告 

软件项目开发完成以后，应与项目实施计划对照，总结实际执行的情况，如进度、成果、资源利用、成本和投入的人力，此外，还需对开发工作做出评价，总结出经验和教训。 

11、软件维护手册 

主要包括软件系统说明、程序模块说明、操作环境、支持软件的说明、维护过程的说明，便于软件的维护。 

12、软件问题报告 

指出软件问题的登记情况，如日期、发现人、状态、问题所属模块等，为软件修改提供准备文档。 

13、软件修改报告 

软件产品投入运行以后，发现了需对其进行修正、更改等问题，应将存在的问题、修改的考虑以及修改的影响作出详细的描述，提交审批。  

# 1.5前端

1.ajax 请求方式、参数类型、状态码?

请求方式：Get，Post

[参数类型：](https://blog.csdn.net/denghut882925/article/details/102373407?ops_request_misc=&request_id=&biz_id=102&utm_term=ajax%25E5%258F%2582%25E6%2595%25B0%25E8%2583%25BD%25E6%259C%2589%25E5%2593%25AA%25E4%25BA%259B%25E7%25B1%25BB%25E5%259E%258B&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-102373407.nonecase)

​	String类型的参数，（默认为当前页地址）发送请求的地址。

​	Object

​	Number类型的参数，设置请求超时时间（毫秒）。

​	Boolean类型的参数

 	xml：返回XML文档，可用JQuery处理。

​         html：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。

​         script：返回纯文本[JavaScript](http://lib.csdn.net/base/javascript)代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求 时（不在同一个域下），所有post请求都将转为get请求。

​         json：返回JSON数据。

​         jsonp：JSONP格式。使用SONP形式调用函数时，例如myurl?callback=?，JQuery将自动替换后一个 “?”为正确的函数名，以执行回调函数。

​         text：返回纯文本字符串。

[状态码：](https://blog.csdn.net/weixin_41484544/article/details/88431849?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160732020819725271627751%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D&request_id=160732020819725271627751&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-88431849.nonecase&utm_term=ajax%20%E7%8A%B6%E6%80%81%E7%A0%81)

1开头的http状态码
表示临时响应并需要请求者继续执行操作的状态代码。
100   （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 
101   （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。

2开头的http状态码
表示请求成功
200     成功处理了请求，一般情况下都是返回此状态码； 
201     请求成功并且服务器创建了新的资源。 
202     接受请求但没创建资源； 
203     返回另一资源的请求； 
204     服务器成功处理了请求，但没有返回任何内容；
205     服务器成功处理了请求，但没有返回任何内容；重置内容，可能需要请求者重置表单内容
206     处理部分请求；

3xx （重定向） 
重定向代码，也是常见的代码
300   （多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 
301   （永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 
302   （临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 
303   （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 
304   （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 
305   （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 
307   （临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。

4xx   表示请求出错 
400    服务器不理解请求的语法。 
401   请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 
403   服务器拒绝请求。 
404   服务器找不到请求的网页。 
405   禁用请求中指定的方法。 
406   无法使用请求的内容特性响应请求的网页。 
407   此状态代码与 401类似，但指定请求者应当授权使用代理。 
408   服务器等候请求时发生超时。 
409   服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 
410   如果请求的资源已永久删除，服务器就会返回此响应。 
411   服务器不接受不含有效内容长度标头字段的请求。 
412   服务器未满足请求者在请求中设置的其中一个前提条件。 
413   服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 
414   请求的 URI（通常为网址）过长，服务器无法处理。 
415   请求的格式不受请求页面的支持。 
416   如果页面无法提供请求的范围，则服务器会返回此状态代码。 
417   服务器未满足”期望”请求标头字段的要求。

5开头状态码并不常见，但是我们应该知道

500   （服务器内部错误）  服务器遇到错误，无法完成请求。 
501   （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 
502   （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 
503   （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 
504   （网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。 
505   （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。

2.[jquery常用的选择器?](https://www.php.cn/js-tutorial-378052.html)

1.1、ID选择器 #id

描述：根据给定的id匹配一个元素， 返回单个元素（注：在网页中，id名称不能重复）

示例：$("#test") 选取 id 为 test 的元素

1.2、类选择器 .class

描述：根据给定的类名匹配元素，返回元素集合

示例：$(".test") 选取所有class为test的元素

1.3、元素选择器 element

描述：根据给定的元素名匹配元素，返回元素集合

示例：$("p") 选取所有的

元素
​	1.4、*
​	描述：匹配所有元素，返回元素集合
​	示例：$("*") 选取所有的元素

3.[前后端是如何做数据交互的?前端怎么传给后端json数据?](https://blog.csdn.net/qq_28289405/article/details/81557957?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160732040919215668895345%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=160732040919215668895345&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-5-81557957.nonecase&utm_term=%E5%89%8D%E5%90%8E%E7%AB%AF%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E7%9A%84)

4.[前后端解决跨域](https://blog.csdn.net/baidu_39120378/article/details/103433125?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160732109219215668884640%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D&request_id=160732109219215668884640&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-103433125.nonecase&utm_term=%E5%89%8D%E5%90%8E%E7%AB%AF%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98)

- 1.Jsonp-- json变种
  最早的解决方案，利用动态去填充script标签可以跨域的原理实现。

```js
	<sccipt src=”http:/wwww/ssss”>
```

限制：

​	需要服务的支持

​	只能发起GET请求

- 2.nginx反向代理(部署)
  思路是：利用nginx反向代理把跨域变为不跨域，支持各种请求方式

  原理是：前端的请求访问后端是跨域，nginx代理会让他的请求转回去访问自己，就不存在跨域问题了，而nginx会代理前端的请求发送一个和后端域名端口一致的请求，再返回数据，相当于避免了前端跨域的直接请求。

  缺点：需要在nginx进行额外配置，语义不清晰 –

- 3.CORS(都可以使用-采纳)
  规范化的跨域请求解决方案，安全可靠。
  优势：

  - 在服务端进行控制是否允许跨域，可自定义规则
  - 支持各种请求方式
    缺点：
  - 会产生额外的请求,要做询问

5.前端如何防止表单重复提交?

​	1.设置submit按钮属性为disabled，然后当后台请求成功移除这个属性。

​	2.用flag标识，当表单被提交过一次后checkSubmitFlg将变为true,根据判断将无法进行提交。 

6.[Vue的生命周期?](https://blog.csdn.net/weixin_42149538/article/details/88808587?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160732137619725271659412%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D&request_id=160732137619725271659412&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-88808587.nonecase&utm_term=Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F) 

vue生命周期是指vue实例对象从创建之初到销毁的过程，vue所有功能的实现都是围绕其生命周期进行的，在生命周期的不同阶段调用对应的钩子函数实现组件数据管理和DOM渲染两大重要功能。

vue生命周期可以分为八个阶段，分别是：beforeCreate(创建前),created(创建后)，beforeMount(载入前),mounted(载入后)，beforeUpdate(更新前),updated（更新后）,beforeDestroy(销毁前)，destroyed（销毁后）

[Vue的指令?](https://blog.csdn.net/q3254421/article/details/88996597?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160732148319725211910451%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=160732148319725211910451&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-88996597.nonecase&utm_term=Vue%E7%9A%84%E6%8C%87%E4%BB%A4%C2%B7) 

**v-for**

用v-for指令根据遍历数组来进行渲染

 **v-bind**

v-bind用来动态的绑定一个或者多个特性。没有参数时，可以绑定到一个包含键值对的对象。常用于动态绑定class和style。以及href等。
简写为一个冒号【 ：】

**v-model**

这个指令用于在表单上创建双向数据绑定。

**v-on**

v-on主要用来监听dom事件，以便执行一些代码块。表达式可以是一个方法名。
简写为：【 @ 】

**1. v-text**

v-text主要用来更新textContent，可以等同于JS的text属性。

```
<span v-text="msg"></span>
```

这两者等价：

```
<span>{{msg}}</span>
```

**2. v-html**

双大括号的方式会将数据解释为纯文本，而非HTML。为了输出真正的HTML，可以用v-html指令。它等同于JS的innerHtml属性。

```
<div v-html="rawHtml"></div>
```

这个div的内容将会替换成属性值rawHtml，直接作为HTML进行渲染。

**3. v-pre**

v-pre主要用来跳过这个元素和它的子元素编译过程。可以用来显示原始的Mustache标签。跳过大量没有指令的节点加快编译。

```
<div id="app">
  <span v-pre>{{message}}</span> //这条语句不进行编译
  <span>{{message}}</span>
</div>
```

最终仅显示第二个span的内容

**4. v-cloak**

这个指令是用来保持在元素上直到关联实例结束时进行编译。

```javascript
<div id="app" v-cloak>
  <div>
    {{message}}
  </div>
</div>
<script type="text/javascript">
  new Vue({
   el:'#app',
   data:{
    message:'hello world'
   }
  })
</script>
```

在页面加载时会闪烁，先显示:

```javascript
<div>
  {{message}}
</div>
```

然后才会编译为：

```html
<div>
  hello world!
</div>
```

**5. v-once**

v-once关联的实例，只会渲染一次。之后的重新渲染，实例极其所有的子节点将被视为静态内容跳过，这可以用于优化更新性能。

```
<span v-once>This will never change:{{msg}}</span> //单个元素
<div v-once>//有子元素
  <h1>comment</h1>
  <p>{{msg}}</p>
</div>
<my-component v-once:comment="msg"></my-component> //组件
<ul>
  <li v-for="i in list">{{i}}</li>
</ul>
```

上面的例子中，msg,list即使产生改变，也不会重新渲染。

**6. v-if**

v-if可以实现条件渲染，Vue会根据表达式的值的真假条件来渲染元素。

```
<a v-if="ok">yes</a>
```

如果属性值ok为true，则显示。否则，不会渲染这个元素。

**7. v-else**

v-else是搭配v-if使用的，它必须紧跟在v-if或者v-else-if后面，否则不起作用。

```
<a v-if="ok">yes</a>
<a v-else>No</a>
```

**8. v-else-if**

v-else-if充当v-if的else-if块，可以链式的使用多次。可以更加方便的实现switch语句。

```
<div v-if="type==='A'">
  A
</div>
<div v-if="type==='B'">
  B
</div>
<div v-if="type==='C'">
  C
</div>
<div v-else>
  Not A,B,C
</div>
```

vue 的双向绑定如何实现?

v-model

原理：vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。

1.实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。

2.实现一个订阅者Watcher，每一个Watcher都绑定一个更新函数，watcher可以收到属性的变化通知并执行相应的函数，从而更新视图。

3.实现一个解析器Compile，可以扫描和解析每个节点的相关指令（v-model，v-on等指令），如果节点存在v-model，v-on等指令，则解析器Compile初始化这类节点的模板数据，使之可以显示在视图上，然后初始化相应的订阅者（Watcher）。



![1607321926316](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1607321926316.png)

[vue如何实现监听?](https://blog.csdn.net/Welkin_qing/article/details/81585786?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160732195119215668860849%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D&request_id=160732195119215668860849&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-81585786.nonecase&utm_term=vue%20%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9B%91%E5%90%AC)

1.绑定keyup事件

2.watch

[Vue如何实现请求?](https://blog.csdn.net/qq_43344133/article/details/90383547?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160732229819724848119703%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=160732229819724848119703&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-10-90383547.nonecase&utm_term=vue%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B)

vue-resource、axios、fetchJsonp

[vue的路由跳转方式?](https://blog.csdn.net/qq_41570658/article/details/107079614?ops_request_misc=&request_id=&biz_id=102&utm_term=vue%25E7%259A%2584%25E8%25B7%25AF%25E7%2594%25B1%25E8%25B7%25B3%25E8%25BD%25AC%25E6%2596%25B9%25E5%25BC%258F?&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-107079614.nonecase)

​	router-link标签

- **this.$router.push跳转到指定url路径，并想history栈中添加一个记录，点击后退会返回到上一个页面**
- **this.$router.replace跳转到指定url路径，但是history栈中不会有记录，点击返回会跳转到上上个页面 (就是直接替换了当前页面)**
- **this.$router.go(n)向前或者向后跳转n个页面，n可为正整数或负整数**

7. get 和post有什么区别?  

   1、 GET主要用于从服务器查询数据，POST用于向服务器提交数据

   2、 GET通过URL传递数据，POST通过http请求体传递数据

   3、 GET传输数据量有限制，不能大于2kb，POST传递的数据量较大，一般大量的数据提交都是通过POST方式

   4、 GET安全性较低，容易在URL中暴漏数据，POST安全性较高

8. jquery 如何获取当前日期?

```javascript
<html>
<head>
<meta http-equiv="content-type" content="text/html;charset=utf-8" />
<title>jquery当前日期</title>
<script type="text/javascript" src="jquery-1.8.2.min.js"></script>
<script type="text/javascript">
 $(function(){
  function show(){
   var mydate = new Date();
   var str = "" + mydate.getFullYear() + "年";
   str += (mydate.getMonth()+1) + "月";
   str += mydate.getDate() + "日";
   return str;
  }
  $("input[type='button']").click(function(){
   $("p").html("今天是 " + show());
  });
 });
</script>
</head>
<body>
<input type="button" value="看看现在的时间" />
<p></p>
</body>
</html>
```



9.如何给画面中所有的checkbox标签添加一个事件?

```javascript
$(function(){
    var s = $("input[name='check']");//获取所有CheckBox标签
    s.each(function(i) {//遍历标签
//          alert(i);
            $(this).click(function(){//绑定事件
                if(this.checked==true){
                      alert(this.value);
                }
             });
        }); 
})
```



10. [jquery 怎么打开一个模态窗口?](https://blog.csdn.net/p15097962069/article/details/105511970?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160765542319724818086638%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=160765542319724818086638&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-105511970.nonecase&utm_term=jquery%20%E6%80%8E%E4%B9%88%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E6%A8%A1%E6%80%81%E7%AA%97%E5%8F%A3&spm=1018.2118.3001.4449)

```javascript
$('#myform').on('submit', function(ev) {
    $('#my-modal').modal({
        show: 'false'
    }); 
 
    var data = $(this).serializeObject();
    json_data = JSON.stringify(data);
    $("#results").text(json_data); 
    $(".modal-body").text(json_data); 
 
    // $("#results").text(data);
 
    ev.preventDefault();
});
```



11.表单验证是如何实现的?

​	0.validator 插件

​	1.正则表达式

​	2.Vant-UI框架

12. readonly和disable有什么区别?

    ## 相同点

    - readonly和disabled都是可以禁止用户更改表单中的内容。比如都设为true，则form属性将不能被编辑

    ## 不同点

    - readonly只针对input（text/password）和textarea有效，而disabled对于所有的表单元素都有效，包括select,radio,checkbox等。
    - 表单在使用GET或POST方式提交时，表单元素在使用了readonly后，值可以传递到后台；而表单元素在使用disabled后值不可以传递到后台。
    - 所有控件都有disabled 属性，但是不一定有readonly属性；点击被readonly掉的按钮照样可以触发事件，但是被disabled掉的按钮就无法使用了不管上面有没有事件。

13. 如何画一个表格?

    1.css+html标签（table，tr，td/th）

    2.latex 表格命令

    如何合并单元格?

    colspan是横向合并    rowspan是纵向合并

14. 如何获取一个文本框的内容?

    **1.用js获取文本框的值：(推荐使用方法1)**

    ​    方法1：**var value = document.getElementById("textId").value**                      //textId为文的id,此时inputValue为输入框的值

    ​    方法2：var value = document.getElementsByClassName("textClass").value     //注意：值为类名的元素值的集合

    ​    方法3：var value = document.getElementsByName("textName").value             //注意：值为带有指定名称的对象值的集合

    ​    方法4：var value = document.getElementsByTagName("标签名对应值").value //注意：值为带有指定标签名的对象值的集合

    **2.用jquery获取文本框的值：(推荐使用方法1)**

    ​    方法1：**var value = $("#textId").val()**

    ​    方法2：var value = $(".textClass").val()             //注意：值为类名的元素值的集合

15. jquery如何获取form表单的值?

    ```javascript
      $("#subbtn").click(function(){
                 var data = {};
    
                 var t = $('form').serializeArray(); 
                 $.each(t, function() { 
                      data [this.name] = this.value; 
                 }); 
                 alert(JSON.stringify(data )); 
                });
    ```

16. 前端如何延时调用一个 函数?

    setTimeout(code,millisec)

    - **参数**

      1、回调函数， 需要隔一定时间后执行的函数

      2、每次调用间隔时间，单位是ms

17.如何取出树形结构的数据?先根遍历，中根遍历，后根遍历

迭代

递归

前端如何显示树形结构数据?

Z-tree

treeTable

18.js中的this在各种情况下的指向?

一、全局作用域或者普通函数自执行中this指向全局对象window

```
//全局作用域
 	console.log(this);//Window 
//普通函数
	function fn(){
     	console.log(this); //Window
   }
    fn(); //函数加括号调用叫函数自执行，函数自执行时，内部的this指向顶层对象/window
```

二、事件函数内部的this指向事件源：注意在事件函数中如果包含普通函数，普通函数自执行后，内部this还是指向window

```
 //事件函数内部的this指向事件源
    document.body.onclick = function(){
    	 this.style.height = "1000px";
      	 console.log(this); //body对象
      	 function fn(){
           console.log(this); //Window
      	 }
      	 fn(); //函数加括号调用叫函数自执行，函数自执行时，内部的this指向顶层对象/window
        };
```

三、对象方法调用时，this指向调用的对象

```
let obj = {
    name : "lanlan",
     fn : function(){
         console.log(this);
     },
     lacy : {
         name : "didi",
         fn : function(){
             let num = 10;
             console.log(this);
         }
     }
 };  
   obj.fn(); //obj
   obj.dudu.fn(); //lacy
```

19.如何将数据保存到前端?

localStorage用于长久的保存整个网站的数据（string类型存储），保存的数据没有过期时间，直到手动删除，并且localStorage的属性是只读的（不过如果是在浏览器的隐私模式下，它是不可读取的）。
另外，如果你只想将数据保存在当前会话下，可以使用sessionStorage，数据将会临时保存，关闭窗口后则会被删除。

**语法**

```javascript
保存数据：
localStorage.setItem("key","value");

读取数据：
var getData=localStorage.getItem("key");

删除数据：
localStorage.removeItem("key");
```

20.如何实时刷新页面?

ajax

[vue](https://blog.csdn.net/parsifalster/article/details/98842106?biz_id=102&utm_term=%E5%A6%82%E4%BD%95%E5%AE%9E%E6%97%B6%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-98842106&spm=1018.2118.3001.4449)

```javascript
provide(){
				return {
					reload: this.reload
				}
			},
```



21.什么是http协议无状态协议?怎么解决http协议无状态协议?

http是无状态的协议，也是不安全的协议，

它的无状态是指对于事务处理没有记忆能力，缺少状态意味着后续的操作需要前面的信息。

解决办法：1，通过cookie解决，2，通过session会话保存。

22.vue父子组件传值

```markdown
		在Vue中，父子组件的关系可以总结为prop向下传递，事件向上传递。父组件通过prop给子组件下发数据，子组件通过事件给父组件发送信息。

		父传子的实现方式就是通过props属性，子组件通过props属性接收从父组件传过来的值，而父组件传值的时候使用 v-bind 将子组件中预留的变量名绑定为data里面的数据即可

		子传父的实现方式就是用了 this.$emit 来遍历 getData 事件，首先用按钮来触发 setData 事件，在 setData 中 用 this.$emit 来遍历 getData 事件，最后返回 this.msg
```

 